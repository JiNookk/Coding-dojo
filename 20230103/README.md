---
name: "\U0001F4A1How to solve it?"
about: 문제를 풀기 전에 어떻게 먼저 풀 것인지 생각을 정리하고, 다풀고나서 반성한다.
title: ''
labels: ''
assignees: ''

---

[참고가이드](https://megaptera.notion.site/6-5f9b4105eb0748fd8f8baa631d92d6ea)

### 1. 이해
- 총 뛰어야 하는 칸 n이 주어진다.
- 한번에 한칸 또는 두칸을 뛸 수 있다.
- 뛸 수 있는 가지수 % 1234567를 리턴한다.
- 중복된 것의 순열 -> n! / m!

### 2. 계획
- 인자의 범위를 구하는 함수
- 인자를 구하는 함수 -> 1, 1, 2 or 2, 2
- 인자가 주어지면 다른 배열을 구성할 수 있는 경우의 수를 구해야 한다. -> 1, 1, 2 or 2, 1, 1 

### 3. 실행
- 

### 4. 반성
- 시간이 모자라서 찾아보니 점화식을 활용한다.

전형적인 DP(Dynamic Programming) 문제이다.
단순하게 경우의 수를 카운팅하여 점화식을 만들었다.

n=1 일 때
[1]
n=2 일 때
[1,1]
[2]
n=3 일 때
[1,1,1]
[1,2]
[2,1]

이에 따라서 
dp[n]=dp[n-1]+dp[n-2]라는 점화식이 도출된다.

한가지 주의할점은 리턴 값에 % 1234567을 적용하면
n이 특정 기준 값을 넘어갈 경우 null이 나온다.
점화식 계산 시 % 처리를 해줘야한다.
